import os
import datetime

# --- CONFIGURATION ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
INPUT_FILE = os.path.join(SCRIPT_DIR, "db_ranges_report.md")
OUTPUT_FILE = os.path.join(SCRIPT_DIR, "db_ranges_summary.md")

# The timestamp format generated by the previous script
# Example: 2025-11-26 11:44:14.000Z
DATE_FMT = '%Y-%m-%d %H:%M:%S.%fZ'


def parse_cell(cell_content):
    """
    Parses a markdown table cell content.
    Input: "T: 2023...<br>B: 2023...<br>S: 123" or "No Data"
    Returns: None if no data, or dict { 'dt': datetime_obj, 't_str': str, 'b_str': str }
    """
    clean_content = cell_content.strip()
    if not clean_content or "No Data" in clean_content or clean_content == "-":
        return None

    try:
        # Split by the HTML break tag used in previous script
        parts = clean_content.split('<br>')

        # Extract T (Device Time) and B (Broker Time)
        # Note: parts[0] is T, parts[1] is B, parts[2] is S (Sequence)
        t_str = parts[0].replace('T:', '').strip()
        b_str = parts[1].replace('B:', '').strip()

        # Parse time for comparison
        dt = datetime.datetime.strptime(t_str, DATE_FMT)

        return {
            'dt': dt,
            't_str': t_str,
            'b_str': b_str
        }
    except Exception as e:
        # If parsing fails (unexpected format), treat as empty
        return None


def main():
    # 1. Check file existence
    if not os.path.exists(INPUT_FILE):
        print(f"‚ùå Error: Input file '{INPUT_FILE}' not found.")
        print("   Please run the 'scan_db_ranges.py' script first to generate the report.")
        return

    print(f"Reading {INPUT_FILE}...")

    with open(INPUT_FILE, 'r') as f:
        lines = f.readlines()

    processed_rows = []

    # 2. Parse the Markdown Table
    # Skip header (0), separator (1)
    # Data starts at index 2
    for line in lines:
        if not line.strip().startswith('|'):
            continue
        if '---' in line or 'ID' in line:
            continue

        # Split row by pipe, remove empty start/end strings resulting from split
        cols = [c.strip() for c in line.split('|')]
        # Remove empty strings caused by leading/trailing pipes
        cols = [c for c in cols if c]

        if not cols:
            continue

        device_id = cols[0]
        data_cells = cols[1:]  # All the Start/End columns

        earliest_start = None
        latest_end = None

        # 3. Iterate all cells to find min/max
        # The logic: We look at ALL start columns and ALL end columns.
        # Ideally, start cols are indices 0, 2, 4... and end are 1, 3, 5...
        # But simply finding min/max of ALL valid dates works for the summary
        # because a Start date will naturally be the minimum and an End date the maximum.

        for i, cell in enumerate(data_cells):
            parsed = parse_cell(cell)
            if parsed:
                # Update Earliest Start
                if earliest_start is None or parsed['dt'] < earliest_start['dt']:
                    earliest_start = parsed

                # Update Latest End
                if latest_end is None or parsed['dt'] > latest_end['dt']:
                    latest_end = parsed

        # 4. Filter empty rows
        if earliest_start and latest_end:
            processed_rows.append({
                'id': device_id,
                'start': earliest_start,
                'end': latest_end
            })

    # 5. Sort by End Date (Descending/Most Recent)
    processed_rows.sort(key=lambda x: x['end']['dt'], reverse=True)

    print(f"Processing complete. Found {len(processed_rows)} active devices.")

    # 6. Write Summary Markdown
    print(f"Writing summary to {OUTPUT_FILE}...")
    with open(OUTPUT_FILE, 'w') as f:
        f.write("# Database Ranges Summary\n\n")
        f.write("Ordered by **Latest Activity** (Descending). Excluding devices with no data.\n\n")

        header = "| ID | Earliest Start (UTC) | Latest End (UTC) |"
        sep = "|---|---|---|"
        f.write(header + "\n")
        f.write(sep + "\n")

        for row in processed_rows:
            # Format: T: <time> <br> B: <time>
            start_str = f"Sensor Time: {row['start']['t_str']}<br>Broker Time: {row['start']['b_str']}"
            end_str = f"Sensor Time: {row['end']['t_str']}<br>Broker Time: {row['end']['b_str']}"

            line = f"| {row['id']} | {start_str} | {end_str} |"
            f.write(line + "\n")

    print("Done.")


if __name__ == "__main__":
    main()